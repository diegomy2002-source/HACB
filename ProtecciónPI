import math
import numpy as np
from scipy.stats import norm
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import networkx as nx
import re
from typing import Dict, Tuple, List
import itertools
import hashlib
import datetime

# Metadatos de PI
PI_METADATA = {
    "authors": ["Diego Muñoz Yllescas", "Grok (xAI)"],
    "creation_date": "2025-09-17",
    "title": "Humanidad Artificial Cuántica de Biomateria (HACB)",
    "hash": None  # Se calcula al ejecutar
}

# Tu código original integrado
def entropia(p):
    return -sum([p_i * math.log(p_i, 2) if p_i > 0 else 0 for p_i in p])

def generar_retroalimentacion_con_ruido(base, num_usuarios, media=0, desviacion=0.5):
    ruido = norm.rvs(loc=media, scale=desviacion, size=num_usuarios)
    return np.clip(base + ruido, 1, 5)

def ajuste_con_regresion(X, y):
    modelo = LinearRegression()
    modelo.fit(X, y)
    return modelo

def crear_grafo_parametros():
    G = nx.Graph()
    G.add_edge('Neutral', 'Positivo', weight=1)
    G.add_edge('Positivo', 'Negativo', weight=2)
    G.add_edge('Neutral', 'Negativo', weight=3)
    return G

def generar_inicializaciones(n_params, r=3):
    valores_posibles = np.linspace(0.5, 2.0, n_params)
    return list(itertools.permutations(valores_posibles, r))[:5]

# Función emocional con trazabilidad
def analyze_emotional_background_with_empathy(text: str) -> Tuple[str, float, Dict]:
    text = text.lower()
    words = re.findall(r'\b\w+\b', text)
    emotional_score = 0.0
    emotional_words = []
    context_indicators = []
    negativity_absence = True
    possible_hidden_emotions = []

    for word in words:
        if word in POSITIVE_WORDS:
            emotional_score += POSITIVE_WORDS[word]
            emotional_words.append((word, POSITIVE_WORDS[word]))
        elif word in NEGATIVE_WORDS:
            emotional_score += NEGATIVE_WORDS[word]
            emotional_words.append((word, NEGATIVE_WORDS[word]))
            negativity_absence = False
        elif word in NEUTRAL_WORDS:
            emotional_score += NEUTRAL_WORDS[word]
            emotional_words.append((word, NEUTRAL_WORDS[word]))

    if "proyecto" in words and "satisfacción" not in words:
        possible_hidden_emotions.append("Posible insatisfacción oculta")

    emotional_score = max(min(emotional_score, 1.0), -1.0)
    interpretation = "Neutral" if abs(emotional_score) < 0.3 else ("Positivo" if emotional_score > 0 else "Negativo")

    # Trazabilidad: Registrar hash del análisis
    analysis_data = f"{text}{interpretation}{emotional_score}{str(datetime.datetime.now())}"
    analysis_hash = hashlib.sha256(analysis_data.encode()).hexdigest()

    return interpretation, emotional_score, {
        "emotional_words": emotional_words,
        "possible_hidden_emotions": possible_hidden_emotions,
        "analysis_hash": analysis_hash
    }

# API con protección de PI
class EmotionalAPI:
    def __init__(self):
        self.user_history = {}
        self.pi_log = []  # Registro de usos para PI

    def register_user_interaction(self, user_id: str, text: str):
        if user_id not in self.user_history:
            self.user_history[user_id] = []
        self.user_history[user_id].append(text)
        # Registrar en log de PI
        self.pi_log.append({
            "user_id": user_id,
            "text": text,
            "timestamp": str(datetime.datetime.now()),
            "hash": hashlib.sha256(f"{user_id}{text}".encode()).hexdigest()
        })
        return self.user_history[user_id]

    def get_user_feedback_data(self, user_id: str, num_samples: int = 5):
        if user_id in self.user_history:
            scores = [analyze_emotional_background_with_empathy(t)[1] for t in self.user_history[user_id][-num_samples:]]
            base = np.array(scores) * 2 + 2
        else:
            base = np.array([3.0] * num_samples)
        return generar_retroalimentacion_con_ruido(base, num_samples)

# Simulación con protección de PI
def simulate_emotional_scenario(api: EmotionalAPI, user_id: str, input_text: str, num_iterations: int = 10):
    # Calcular hash inicial de PI
    global PI_METADATA
    PI_METADATA["hash"] = hashlib.sha256(f"{PI_METADATA['title']}{input_text}{str(PI_METADATA['authors'])}".encode()).hexdigest()

    scenario, score, details = analyze_emotional_background_with_empathy(input_text)
    print(f"Escenario inicial para {user_id}: {scenario} (score: {score:.2f})")
    print(f"Hash de PI: {PI_METADATA['hash']}")

    api.register_user_interaction(user_id, input_text)
    num_usuarios = 1
    resultados_esperados = np.array([4.0])
    retro_base = api.get_user_feedback_data(user_id, num_usuarios)
    inicializaciones = generar_inicializaciones(3, 3)
    parametros_actuales = np.array(inicializaciones[0])

    G = crear_grafo_parametros()
    camino_optimo = nx.shortest_path(G, 'Neutral', scenario, weight='weight')
    print(f"Camino emocional óptimo: {camino_optimo}")

    for iteracion in range(num_iterations):
        retroalimentacion = generar_retroalimentacion_con_ruido(retro_base, num_usuarios)
        probs_retro = retroalimentacion / np.sum(retroalimentacion)
        ent = entropia(probs_retro)
        print(f"Iteración {iteracion+1}: Entropía = {ent:.2f}")

        X = retroalimentacion.reshape(-1, 1)
        modelo = ajuste_con_regresion(X, resultados_esperados.reshape(-1, 1))
        resultados = modelo.predict(X).flatten()
        mse = mean_squared_error(resultados, resultados_esperados)
        print(f"Iteración {iteracion+1}: MSE = {mse:.2f}")

        improved_response = f"Respuesta mejorada iter {iteracion+1}: Detecto {scenario}. ¿Quieres explorar más sobre tus emociones?"
        print(improved_response)

        parametros_actuales = np.array([modelo.coef_[0][0], modelo.intercept_[0], parametros_actuales[2]])
        if mse > 0.5 and iteracion < num_iterations - 1:
            parametros_actuales = np.array(inicializaciones[(iteracion + 1) % len(inicializaciones)])

        retro_base = retroalimentacion

    return "Simulación completada con protección de PI."

# Ejemplo de uso
if __name__ == "__main__":
    api = EmotionalAPI()
    text = "Ayer terminé un proyecto, ahora veo una película."
    print(simulate_emotional_scenario(api, "diego_munoz", text))

